## Set
value만을 저장하며 중복을 허용하지 않는 Collection
* 생성자 : new Set()
* 개수확인 : Set.size
* 요소 추가 : Set.add(value)    // 다양한 자료형을 value로 사용 가능하며 set.add 호출 시 set이 반환되므로 체이닝(chaining) 가능
* 요소 삭제 : Set.delete(value) // 다양한 자료형을 value로 사용 가능하며 set.add 호출 시 set이 반환되므로 체이닝(chaining) 가능
* 전체 삭제 : Set.clear()
* 요소 존재 여부 확인 : Set.has(key)
* 그 밖에 메서드 : Set.keys(), Set.values(), Set.entires()
```js
let set = new Set();
let num = new Set([1, 2, 3, 4, 5]);
let str = new Set("Hello!");

console.log(set); // output: Set(0){}
console.log(num); // output: Set(5){1, 2, 3, 4, 5}
console.log(str); // output: Set(5){'H', 'e', 'l', 'o', '!'} 중복된 l은 제거

// 1. add
set.add(1).add(1).add(10).add(20);
console.log(set); // output: Set(3){1, 10, 20} 중복된 1은 제거

//  2. has
console.log(set.has(10)); // output: true
console.log(set.has(2));  // output: false

// 3. delete
set.delete(1);
set.delete(-1);   // 없는 요소를 넣어도 변화는 없음
console.log(set); // output: Set(2){10, 20}
```
### Set 반복문
Collection 객체인 Set이 가지고 있는 iterator 속성을 이용하여 for ... of 구문을 통해 반복문 수행 가능
```js
let str = new Set("Hello!");

console.log(str); // output: Set(5){'H', 'e', 'l', 'o', '!'}

for (let item of str) console.log(item); // str_Set 객체를 넣어주고, item_value가 item으로 return된다. output: H e l o !
for (let item of str.keys()) console.log(item); // keys_Set은 key가 없어서 동일하게 출력 output: H e l o !
for (let item of str.values()) console.log(item); // output: H e l o !
for (let item of str.entries()) console.log(item); // output: [ 'H', 'H' ] [ 'e', 'e' ] [ 'l', 'l' ] [ 'o', 'o' ] [ '!', '!' ]

console.log(str.keys()); // output: [Set Iterator] { 'H', 'e', 'l', 'o', '!' }
console.log(str.entries()); // output: [Set Entries] {[ 'H', 'H' ], [ 'e', 'e' ], [ 'l', 'l' ], [ 'o', 'o' ], [ '!', '!' ]}
```
## Math
표준 Built-in 객체로써 수학적인 연산을 위한 속성값과 메서드를 제공하는 객체<br>
Math는 생성자 함수가 아니며 모든 속성과 메서드는 정적이기에 Math.function()으로 언제든 호출 가능
* 오일러 상수(e) : Math.E
* PI : Math.PI
* 절대값 : Math.abs(x)
* 최대값 : Math.max(x)
* 최소값 : Math.min(x)
* 랜덤 난수 값 : Math.random()
```js
// 1. MAX / MIN
console.log(Math.max(1, -1)); // output: 1
console.log(Math.min(1, -1)); // output: -1

console.log(Math.max(1, -1, 5, 23, 17, -4)); // output: 23
console.log(Math.min(1, -1, 5, 23, 17, -4)); // output: -4

let nums = [1, -1, 5, 23, 17, -4]; // 배열을 인수로 받아 최대/최소를 산출하려면 apply 함수 혹은 스프레드 문법 사용 필요
// use apply
console.log(Math.max.apply(null, nums)); // output: 23
console.log(Math.min.apply(null, nums)); // output: -4
// use spread
console.log(Math.max(...nums)); // output: 23
console.log(Math.min(...nums)); // output: -4

// 2. ABS
console.log(Math.abs(1)); // output: 1
console.log(Math.abs(-1)); // output: 1
console.log(Math.abs(-Infinity)); // output: infinity

// 3. Math property
console.log(Math.E);  // output: 2.718281828459045
console.log(Math.PI); // output: 3.141592653589793

// 4. Random
for (let i = 0; i < 3; i++) {
    console.log(Math.random());
} // output: 0.10650103922054699 0.9001316163312043 0.48248559546655545

for (let i = 0; i < 3; i++) {
    console.log(Number.parseInt(Math.random() * 10));
} // output: 6 9 3
```
* 제곱 : Math.pow(x,y)
* 제곱근 : Math.sqrt(x)
* 소수점 이하 반올림 정수 : Math.round(x)
* 소수점 이하 올림 : Math.ceil(x)
* 소수점 이하 내림 : Math.floor(x)
```js
// 1. pow
console.log(Math.pow(2, 3)); // output: 8
console.log(2 ** 3);         // output: 8

// 2. sqrt
console.log(Math.sqrt(4));  // output: 2
console.log(Math.sqrt(2));  // output: 1.4142135623730951

// 3. round, ceil, floor
console.log(Math.round(3.5));  // output: 4
console.log(Math.round(-2.3)); // output: -2
console.log(Math.round(-2.7)); // output: -3

console.log(Math.ceil(3.5));   // output: 4
console.log(Math.ceil(-2.3));  // output: -2
console.log(Math.ceil(-2.7));  // output: -2

console.log(Math.floor(3.5));  // output: 4
console.log(Math.floor(-2.3)); // output: -3
console.log(Math.floor(-2.7)); // output: -3
```
## Date
